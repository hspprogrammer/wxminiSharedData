{"version":3,"file":"./lib/index.js","mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://wxminishareddata/./src/resetMini.js","webpack://wxminishareddata/./src/reset.ts","webpack://wxminishareddata/./src/responsive.ts","webpack://wxminishareddata/./src/store.ts","webpack://wxminishareddata/./src/utils.ts","webpack://wxminishareddata/webpack/bootstrap","webpack://wxminishareddata/webpack/runtime/define property getters","webpack://wxminishareddata/webpack/runtime/hasOwnProperty shorthand","webpack://wxminishareddata/webpack/runtime/make namespace object","webpack://wxminishareddata/./src/index.ts"],"sourcesContent":["import { setStoreToPage, storeCommit, storeDispatch, destroyFn, getStoreData, storeGetters } from \"./store\";\nimport { effect, destroyDep, onShowEffectRun } from \"./responsive\";\nfunction reSetPage() {\n  // @ts-ignore\n  var cPage = Page;\n  Page = function Page(options) {\n    options[\"$setStoreToPage\"] = setStoreToPage;\n    options[\"$storeCommit\"] = storeCommit;\n    options[\"$storeDispatch\"] = storeDispatch;\n    options[\"$effect\"] = effect;\n    options[\"$getStoreData\"] = getStoreData;\n    options[\"$storeGetters\"] = storeGetters;\n    if (!options[\"onLoad\"]) options[\"onLoad\"] = function () {};\n    if (!options[\"onShow\"]) options[\"onShow\"] = function () {};\n    var cOnLoad = options[\"onLoad\"];\n    options[\"onLoad\"] = function () {\n      this.$storeData = getStoreData();\n      return cOnLoad.apply(this, Array.prototype.slice.call(arguments));\n    };\n    var cOnShow = options[\"onShow\"];\n    options[\"onShow\"] = function () {\n      onShowEffectRun();\n      return cOnShow.apply(this, Array.prototype.slice.call(arguments));\n    };\n    if (!options[\"onUnload\"]) options[\"onUnload\"] = function () {};\n    var cOnUnload = options[\"onUnload\"];\n    options[\"onUnload\"] = function () {\n      destroyFn.call(this);\n      destroyDep.call(this);\n      return cOnUnload.apply(this, Array.prototype.slice.call(arguments));\n    };\n    cPage(options);\n  };\n}\nfunction reSetComponents(StoreData) {\n  // @ts-ignore\n  var cComponent = Component;\n  Component = function Component(options) {\n    if (!options[\"methods\"]) options[\"methods\"] = {};\n    options[\"methods\"][\"$setStoreToPage\"] = setStoreToPage;\n    options[\"methods\"][\"$storeCommit\"] = storeCommit;\n    options[\"methods\"][\"$storeDispatch\"] = storeDispatch;\n    options[\"methods\"][\"$effect\"] = effect;\n    options[\"methods\"][\"$getStoreData\"] = getStoreData;\n    options[\"methods\"][\"$storeGetters\"] = storeGetters;\n    if (!options[\"detached\"]) options[\"detached\"] = function () {};\n    var cDetached = options[\"detached\"];\n    options[\"detached\"] = function () {\n      destroyFn.call(this);\n      destroyDep.call(this);\n      return cDetached.apply(this, Array.prototype.slice.call(arguments));\n    };\n    cComponent(options);\n  };\n}\nreSetPage();\nreSetComponents();","import reactive, { TriggerType, collect, trigger, RAW_TARGET, ITERATE_KEY, MAP_KEYS_ITERATE_KEY } from \"./responsive\";\n/**\n * 重写数组方法\n */\nlet shoulCollect = true;\nconst arrayInstrumentations = {};\n['includes', \"indexOf\", \"lastIndexOf\"].forEach((method) => {\n    const originMethod = Array.prototype[method];\n    arrayInstrumentations[method] = function (...args) {\n        let res = originMethod.apply(this, args);\n        if (res === false) {\n            res = originMethod.apply(this[RAW_TARGET], args);\n        }\n        return res;\n    };\n});\n['push', \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((method) => {\n    const originMethod = Array.prototype[method];\n    arrayInstrumentations[method] = function (...args) {\n        shoulCollect = false;\n        for (let i = 0; i < args.length; i++) {\n            args[i] = args[i][RAW_TARGET] || args[i];\n        }\n        let res = originMethod.apply(this, args);\n        shoulCollect = true;\n        return res;\n    };\n});\n/**\n * 重写Set、Map相关方法\n */\nconst mutableInstrumentations = {\n    add(key) {\n        const target = this[RAW_TARGET];\n        const rawkey = key[RAW_TARGET] || key;\n        const hasKey = target.has(rawkey);\n        const res = target.add(rawkey);\n        if (!hasKey) {\n            trigger(target, key, TriggerType.ADD);\n        }\n        return res;\n    },\n    delete(key) {\n        const target = this[RAW_TARGET];\n        const hasKey = target.has(key);\n        const res = target.delete(key);\n        if (hasKey) {\n            trigger(target, key, TriggerType.DEL);\n        }\n        return res;\n    },\n    get(key) {\n        const target = this[RAW_TARGET];\n        const hasKey = target.has(key);\n        collect(target, key);\n        if (hasKey) {\n            const res = target.get(key);\n            return typeof res === \"object\" ? reactive(res) : res;\n        }\n    },\n    set(key, val) {\n        const target = this[RAW_TARGET];\n        const hasKey = target.has(key);\n        const oldVal = target.get(key);\n        const rawVal = val[RAW_TARGET] || val;\n        target.set(key, rawVal);\n        if (!hasKey) {\n            trigger(target, key, TriggerType.ADD);\n        }\n        else if (oldVal !== val && (oldVal === oldVal && val === val)) {\n            trigger(target, key, TriggerType.SET);\n        }\n    },\n    forEach(cb, thref) {\n        const target = this[RAW_TARGET];\n        collect(target, ITERATE_KEY);\n        const warp = (val) => {\n            return typeof val === \"object\" && val !== null ? reactive(val) : val;\n        };\n        target.forEach((v, k) => {\n            cb.call(thref, warp(v), warp(k), this);\n        });\n    },\n    [Symbol.iterator]: iterationMethod(),\n    entries: iterationMethod(),\n    values: iterationMethod(2),\n    keys: iterationMethod(3),\n};\nfunction iterationMethod(type = 1) {\n    return () => {\n        const target = this[RAW_TARGET];\n        const itr = target[Symbol.iterator]();\n        const warp = (val) => {\n            return typeof val === \"object\" && val !== null ? reactive(val) : val;\n        };\n        type === 3 ? collect(target, MAP_KEYS_ITERATE_KEY) : collect(target, ITERATE_KEY);\n        return {\n            next() {\n                const { value, done } = itr.next();\n                if (type === 1) {\n                    return {\n                        value: value ? [warp(value[0]), warp[value[1]]] : value,\n                        done\n                    };\n                }\n                else if (type === 2) {\n                    return {\n                        value: value ? warp(value[0]) : value,\n                        done\n                    };\n                }\n                else if (type === 3) {\n                    return {\n                        value: warp(value),\n                        done\n                    };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            }\n        };\n    };\n}\nexport { arrayInstrumentations, shoulCollect, mutableInstrumentations };\n","import { arrayInstrumentations, shoulCollect, mutableInstrumentations } from \"./reset\";\nimport { pageBucket } from \"./store\";\nimport { isEqualObj } from \"./utils\";\nlet effectId = 1;\nexport var TriggerType;\n(function (TriggerType) {\n    TriggerType[\"SET\"] = \"SET\";\n    TriggerType[\"ADD\"] = \"ADD\";\n    TriggerType[\"DEL\"] = \"DEL\";\n})(TriggerType || (TriggerType = {}));\nconst reactiveMap = new Map();\nexport const ITERATE_KEY = Symbol();\nexport const MAP_KEYS_ITERATE_KEY = Symbol();\nexport const RAW_TARGET = Symbol();\n// 存储响应数据与副作用函数的对应关系\nconst effectBucket = new WeakMap();\n//缓存页面中所有的副作用函数，以便于页面销毁时清除\nconst pageEffectMap = new WeakMap();\n// 缓存应该在onshow中调用的副作用函数\nexport const effectRunAtOnShowMap = new WeakMap();\n//临时存储副作用函数的栈\nconst effectStack = [];\nlet activeEffect = null;\n/**\n * 注册副作用函数\n * @param {function} fn\n * @param {effectOptions} options\n */\nexport function effect(fn, options) {\n    const effectFn = () => {\n        cleanup(effectFn);\n        activeEffect = effectFn;\n        effectStack.push(effectFn);\n        fn();\n        effectStack.pop();\n        activeEffect = effectStack[effectStack.length - 1];\n    };\n    effectFn.options = options || { lazy: true };\n    effectFn.deps = [];\n    // @ts-ignore\n    const currentpage = getCurrentPages()[0];\n    effectFn.page = currentpage;\n    effectFn._id = effectId;\n    effectId++;\n    let pageEffects = pageEffectMap.get(this);\n    if (!pageEffects) {\n        this && pageEffectMap.set(this, (pageEffects = []));\n    }\n    pageEffects && pageEffects.push(effectFn);\n    if (options && options.scheduler) {\n        options.scheduler(effectFn);\n    }\n    else {\n        effectFn();\n    }\n}\nfunction cleanup(effectFn) {\n    for (let i = 0; i < effectFn.deps.length; i++) {\n        const deps = effectFn.deps[i];\n        deps.delete(effectFn);\n    }\n    effectFn.deps.length = 0;\n}\nexport function destroyDep() {\n    let pageEffects = pageEffectMap.get(this) || [];\n    for (let i = 0; i < pageEffects.length; i++) {\n        cleanup(pageEffects[i]);\n    }\n    pageEffects.length = 0;\n}\nexport function createReactive(data, isShallow = false) {\n    return new Proxy(data, {\n        get(target, key, receiver) {\n            if (key === RAW_TARGET) {\n                return target;\n            }\n            if (target instanceof Set || target instanceof WeakSet || target instanceof Map || target instanceof WeakMap) {\n                if (key === \"size\") {\n                    collect(target, ITERATE_KEY);\n                    return Reflect.get(target, key, target);\n                }\n                return mutableInstrumentations[key] || target[key].bind(target);\n            }\n            if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) {\n                return Reflect.get(arrayInstrumentations, key, receiver);\n            }\n            const res = Reflect.get(target, key, receiver);\n            if (typeof key !== \"symbol\") {\n                collect(target, key);\n            }\n            if (isShallow) {\n                return res;\n            }\n            if (typeof res === \"object\" && res !== null) {\n                return reactive(res);\n            }\n            return res;\n        },\n        set(target, key, newVal, receiver) {\n            const oldVal = target[key];\n            const type = Array.isArray(target)\n                ? Number(key) < target.length\n                    ? TriggerType.SET\n                    : TriggerType.ADD\n                : Object.prototype.hasOwnProperty.call(target, key)\n                    ? TriggerType.SET\n                    : TriggerType.ADD;\n            newVal = newVal[RAW_TARGET] || newVal;\n            const res = Reflect.set(target, key, newVal, receiver);\n            if (target === receiver[RAW_TARGET]) {\n                // if (oldVal !== newVal && (oldVal === oldVal || newVal === newVal)) {\n                //   trigger(target, key, type, newVal);\n                // }\n                if (!isEqualObj(newVal, oldVal) && (oldVal === oldVal || newVal === newVal)) {\n                    trigger(target, key, type, newVal);\n                }\n            }\n            const pageMap = pageBucket[key];\n            if (pageMap) {\n                pageMap.forEach((keySet, page) => {\n                    const data = {};\n                    keySet.forEach((_key) => {\n                        data[_key] = newVal;\n                    });\n                    page.setData(data);\n                });\n            }\n            return res;\n        },\n        has(target, key) {\n            collect(target, key);\n            return Reflect.has(target, key);\n        },\n        ownKeys(target) {\n            collect(target, Array.isArray(target) ? \"length\" : ITERATE_KEY);\n            return Reflect.ownKeys(target);\n        },\n        deleteProperty(target, key) {\n            const haskey = Object.prototype.hasOwnProperty.call(target, key);\n            const res = Reflect.deleteProperty(target, key);\n            if (res && haskey) {\n                trigger(target, key, TriggerType.DEL, Number.MAX_SAFE_INTEGER);\n            }\n            return res;\n        },\n    });\n}\n// 副作用函数和数据建立映射关系\nexport function collect(target, key) {\n    if (!activeEffect || !shoulCollect)\n        return;\n    // 获取target对应的key与副作用函数的Map\n    let depsMap = effectBucket.get(target);\n    if (!depsMap) {\n        effectBucket.set(target, (depsMap = new Map()));\n    }\n    // 获取key下的副作用函数列表\n    let deps = depsMap.get(key);\n    if (!deps) {\n        depsMap.set(key, (deps = new Set()));\n    }\n    // 将副作用函数添加进去\n    deps.add(activeEffect);\n    activeEffect.deps.push(deps);\n}\nexport function trigger(target, key, type, newVal) {\n    let depsMap = effectBucket.get(target);\n    if (!depsMap)\n        return true;\n    const effects = depsMap.get(key);\n    const effectToRun = new Set();\n    effects &&\n        effects.forEach((effectFn) => {\n            if (effectFn != activeEffect) {\n                effectToRun.add(effectFn);\n            }\n        });\n    if (type === TriggerType.ADD || type === TriggerType.DEL || (type === TriggerType.SET && (target instanceof Map || target instanceof WeakMap))) {\n        const iterateEffects = depsMap.get(ITERATE_KEY);\n        iterateEffects &&\n            iterateEffects.forEach((effectFn) => {\n                if (effectFn != activeEffect) {\n                    effectToRun.add(effectFn);\n                }\n            });\n    }\n    if (type === TriggerType.ADD || type === TriggerType.DEL || target instanceof Map || target instanceof WeakMap) {\n        const iterateEffects = depsMap.get(MAP_KEYS_ITERATE_KEY);\n        iterateEffects &&\n            iterateEffects.forEach((effectFn) => {\n                if (effectFn != activeEffect) {\n                    effectToRun.add(effectFn);\n                }\n            });\n    }\n    if (type === TriggerType.ADD && Array.isArray(target)) {\n        const lengthEffects = depsMap.get(\"length\");\n        lengthEffects &&\n            lengthEffects.forEach((effectFn) => {\n                if (effectFn != activeEffect) {\n                    effectToRun.add(effectFn);\n                }\n            });\n    }\n    if (Array.isArray(target) && key === \"length\") {\n        depsMap.forEach((effects, key) => {\n            if (key >= newVal) {\n                effects.forEach((effectFn) => {\n                    if (effectFn != activeEffect) {\n                        effectToRun.add(effectFn);\n                    }\n                });\n            }\n        });\n    }\n    // @ts-ignore\n    const currentpage = getCurrentPages()[0];\n    effectToRun &&\n        effectToRun.forEach((effectFn) => {\n            var _a, _b;\n            if (effectFn.options.lazy) {\n                if (effectFn.page === currentpage) {\n                    if ((_a = effectFn.options) === null || _a === void 0 ? void 0 : _a.scheduler) {\n                        effectFn.options.scheduler(effectFn);\n                    }\n                    else {\n                        effectFn();\n                    }\n                }\n                else {\n                    let effectSet = effectRunAtOnShowMap.get(effectFn.page);\n                    if (!effectSet) {\n                        effectRunAtOnShowMap.set(effectFn.page, (effectSet = new WeakSet()));\n                    }\n                    effectSet.add(effectFn);\n                }\n            }\n            else {\n                if ((_b = effectFn.options) === null || _b === void 0 ? void 0 : _b.scheduler) {\n                    effectFn.options.scheduler(effectFn);\n                }\n                else {\n                    effectFn();\n                }\n            }\n        });\n}\nexport default function reactive(obj) {\n    const existionProxy = reactiveMap.get(obj);\n    if (existionProxy)\n        return existionProxy;\n    const proxy = createReactive(obj);\n    reactiveMap.set(obj, proxy);\n    return proxy;\n}\n// 在onShow中执行effect\nexport function onShowEffectRun() {\n    // @ts-ignore\n    const currentpage = getCurrentPages()[0];\n    const effectSet = effectRunAtOnShowMap.get(currentpage) || [];\n    console.log(effectSet);\n    [...effectSet].forEach((effectFn) => {\n        var _a;\n        if ((_a = effectFn.options) === null || _a === void 0 ? void 0 : _a.scheduler) {\n            effectFn.options.scheduler(effectFn);\n        }\n        else {\n            effectFn();\n        }\n    });\n}\n","import reactive, { effect } from \"./responsive\";\n//存储页面实例\nexport const pageBucket = {};\nlet StoreModulesBucket = {};\nexport let StoreData = {};\nlet StoreGettersBucket = {};\nlet StoreMutationsBucket = {};\nlet StoreActionsBucket = {};\n/**\n *\n * @param object\n */\nexport function setStoreToPage(object) {\n    let setDataObj = {};\n    for (const key in object) {\n        if (Object.hasOwnProperty.call(object, key)) {\n            const path = object[key];\n            const storeDatakey = path.split('.')[0];\n            let pageMap = pageBucket[storeDatakey];\n            if (!pageMap) {\n                pageMap = new Map();\n                pageMap.set(this, new Set());\n            }\n            if (!pageMap.has(this)) {\n                pageMap.set(this, new Set());\n            }\n            pageMap.get(this).add(key);\n            pageBucket[storeDatakey] = pageMap;\n            StoreData && (StoreData[storeDatakey] != null && (setDataObj[key] = StoreData[storeDatakey]));\n        }\n    }\n    this.setData(setDataObj);\n}\n;\nexport function storeGetters(key) {\n    return StoreGettersBucket[key]();\n    ;\n}\nexport function storeCommit() {\n    const key = arguments[0];\n    if (!key)\n        return console.error(`请输入store的mutations名称`);\n    if (StoreMutationsBucket[key]) {\n        const keys = key.split(\"/\");\n        keys.pop();\n        arguments[0] = keys.length ? keys.reduce((accumulator, currentKey) => accumulator[currentKey], StoreData) : StoreData;\n        StoreMutationsBucket[key].apply(this, [...arguments]);\n    }\n    else {\n        console.error(`未找到${key},请输入store正确的mutations`);\n    }\n}\nexport function storeDispatch(key) {\n    // const key = arguments[0];\n    if (!key)\n        return console.error(`请输入store的actions名称`);\n    if (StoreActionsBucket[key]) {\n        const keys = key.split(\"/\");\n        keys.pop();\n        arguments[0] = {\n            storeCommit,\n            StoreData: keys.length ? keys.reduce((accumulator, currentKey) => accumulator[currentKey], StoreData) : StoreData\n        };\n        StoreActionsBucket[key].apply(this, [...arguments]);\n    }\n    else {\n        console.error(`未找到${key},请输入store正确的actions`);\n    }\n}\nexport function destroyFn() {\n    if (!StoreData)\n        return;\n    for (const key in StoreData) {\n        if (Object.hasOwnProperty.call(StoreData, key)) {\n            if (pageBucket[key] && pageBucket[key].has(this)) {\n                pageBucket[key].delete(this);\n            }\n        }\n    }\n}\nfunction Store(options) {\n    const cacheGetters = {};\n    if (!options['name'])\n        options['name'] = \"\";\n    if (!options['modules'])\n        options['modules'] = {};\n    if (!options['data'])\n        options['data'] = {};\n    if (!options['getters'])\n        options['getters'] = {};\n    if (!options['mutations'])\n        options['mutations'] = {};\n    if (!options['actions'])\n        options['actions'] = {};\n    for (const key in options['modules']) {\n        const module = options['modules'][key];\n        const moduleName = module.name || key;\n        options['data'][moduleName] = module.data || null;\n        if (module.getters) {\n            for (const getterName in module.getters) {\n                if (Object.prototype.hasOwnProperty.call(module.getters, getterName)) {\n                    options['getters'][`${moduleName}/${getterName}`] = module.getters[getterName];\n                }\n            }\n        }\n        if (module.mutations) {\n            for (const mutationsName in module.mutations) {\n                if (Object.prototype.hasOwnProperty.call(module.mutations, mutationsName)) {\n                    options['mutations'][`${moduleName}/${mutationsName}`] = module.mutations[mutationsName];\n                }\n            }\n        }\n        if (module.actions) {\n            for (const actionName in module.actions) {\n                if (Object.prototype.hasOwnProperty.call(module.actions, actionName)) {\n                    options['actions'][`${moduleName}/${actionName}`] = module.actions[actionName];\n                }\n            }\n        }\n    }\n    StoreData = reactive(options['data']);\n    StoreModulesBucket = options['modules'];\n    for (const key in options['getters']) {\n        if (Object.prototype.hasOwnProperty.call(options['getters'], key)) {\n            StoreGettersBucket[key] = () => {\n                if (cacheGetters[key])\n                    return cacheGetters[key];\n                effect(() => {\n                    delete cacheGetters[key];\n                    if (options['getters']) {\n                        cacheGetters[key] = options['getters'][key](StoreData);\n                    }\n                });\n                return cacheGetters[key];\n            };\n        }\n    }\n    StoreMutationsBucket = options['mutations'];\n    StoreActionsBucket = options['actions'];\n    // return {\n    //   StoreData\n    // };\n}\nexport function getStoreData() {\n    return StoreData;\n}\nexport default Store;\n","export function isEqualObj(obj1, obj2) {\n    // 判断类型是否相等\n    if (typeof obj1 !== typeof obj2) {\n        return false;\n    }\n    // 如果是基本类型直接比较值\n    if (typeof obj1 !== 'object' || obj1 === null || obj2 === null) {\n        return obj1 === obj2;\n    }\n    // 获取两个对象的属性名数组\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    // 属性数量不相等，返回false\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    // 比较每个属性的值\n    for (let key of keys1) {\n        if (!isEqualObj(obj1[key], obj2[key])) {\n            return false;\n        }\n    }\n    return true;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import pkg from \"../package.json\";\nimport Store, { setStoreToPage, storeCommit, storeDispatch, getStoreData, storeGetters } from \"./store\";\nimport { effect } from \"./responsive\";\nimport \"./resetMini\";\nconst Version = pkg.version;\nconsole.log(\"%c当前wxminiSharedData版本：\" + Version, \"color: red;\");\nexport { setStoreToPage, storeCommit, storeDispatch, getStoreData, storeGetters, effect };\nexport default Store;\n"],"names":[],"sourceRoot":""}